# REQ-001: Configurable Database Backend (Supabase → PostgreSQL+pgvector Decoupling)

## STATUS: IMPLEMENTED
**Created**: 2026-02-17 | **Context**: Infrastructure / Database Layer
**Completed**: 2026-02-17

---

## PROBLEM
Archon está acoplado a Supabase como única opción de base de datos. Usuarios que quieren autohosting completo o evitar dependencias cloud no pueden usar un PostgreSQL local con pgvector.

## VALUE
- Despliegue 100% local sin cuentas cloud (privacidad, coste, control)
- Paridad funcional: mismo schema SQL, misma búsqueda vectorial via pgvector
- Configuración único punto: variable de entorno `DB_PROVIDER`

## ACCEPTANCE CRITERIA
- [x] `DB_PROVIDER=supabase` → comportamiento idéntico al actual
- [x] `DB_PROVIDER=postgres` → usa adapter PostgreSQL contra PostgreSQL con pgvector
- [x] `docker compose --profile postgres-standalone up` levanta PostgreSQL+pgvector listo
- [x] Migrations SQL ejecutan contra ambos backends sin modificación de schema base
- [x] RAG search (vector similarity) expuesto via capa RPC en ambos backends
- [x] Ningún servicio del backend principal importa `supabase` directamente (solo via abstracción)
- [x] `.env.example` actualizado con ambos conjuntos de variables

---

## IMPLEMENTATION SUMMARY
- Se creó la capa de abstracción en `python/src/server/db/` con Protocol + adapters + factory.
- `client_manager.py` quedó desacoplado de Supabase y ahora delega en `get_db_client()`.
- Se agregó soporte de PostgreSQL standalone con perfil Docker `postgres-standalone`.
- Se documentó configuración por provider en `.env.example` y arquitectura técnica.

---

## TECH CONTEXT

### Bounded Context: Infrastructure / Database
- Archivo central: `python/src/server/services/client_manager.py`
- `get_supabase_client()` → único punto de creación del cliente
- 6+ servicios consumen `supabase-py` API: `.table().select().execute()`
- Schema: PostgreSQL + pgvector (compatible con standalone)

### Supabase API Patterns en uso
```python
client.table("archon_sources").select("*").execute()
client.table("archon_sources").insert({...}).execute()
client.table("archon_sources").update({...}).eq("id", id).execute()
client.table("archon_sources").delete().eq("id", id).execute()
# RPC calls para vector search:
client.rpc("match_documents", {params}).execute()
```

### pgvector Stack objetivo (standalone)
- Driver: `asyncpg` o `psycopg2` (sync para preservar sync interface)
- Extension: `pgvector` con HNSW index, `halfvec` para embeddings
- Schema idéntico al definido en `migration/complete_setup.sql`

---

## INVARIANTS (notación matemática)

```
I-1: ∀ db_op ∈ DatabaseOperations: interface(SupabaseAdapter) ≡ interface(PostgresAdapter)
     (Liskov Substitution — intercambiabilidad garantizada)

I-2: ∄ service ∈ BackendServices: direct_import(supabase) = True
     (Supabase solo accesible via abstracción tras implementación)

I-3: DB_PROVIDER ∈ {supabase, postgres} ∧ default(DB_PROVIDER) = supabase
     (backward compatibility obligatoria)

I-4: schema(SupabaseDB) ≡ schema(StandaloneDB)
     (mismas migrations SQL, ningún DDL divergente)

I-5: ∀ embedding ∈ Documents: dim(embedding) = dim(query_embedding)
     (halfvec dimensión constante, no nula, nunca zero-vector)
```

---

## OUT OF SCOPE
- Migración de datos entre backends (herramienta externa)
- Multi-tenant o sharding
- Supabase Auth / Storage (no usados en Archon Core)
